{"ast":null,"code":"import { defineComponent, computed, shallowRef, ref, onMounted, watch, onBeforeUnmount, openBlock, createElementBlock, normalizeStyle, renderSlot } from 'vue';\nimport { useMutationObserver } from '@vueuse/core';\nimport { watermarkProps } from './watermark.mjs';\nimport { getStyleStr, getPixelRatio, reRendering } from './utils.mjs';\nimport useClips, { FontGap } from './useClips.mjs';\nimport _export_sfc from '../../../_virtual/plugin-vue_export-helper.mjs';\nconst __default__ = defineComponent({\n  name: \"ElWatermark\"\n});\nconst _sfc_main = /* @__PURE__ */defineComponent({\n  ...__default__,\n  props: watermarkProps,\n  setup(__props) {\n    const props = __props;\n    const style = {\n      position: \"relative\"\n    };\n    const color = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) == null ? void 0 : _a.color) != null ? _b : \"rgba(0,0,0,.15)\";\n    });\n    const fontSize = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) == null ? void 0 : _a.fontSize) != null ? _b : 16;\n    });\n    const fontWeight = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) == null ? void 0 : _a.fontWeight) != null ? _b : \"normal\";\n    });\n    const fontStyle = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) == null ? void 0 : _a.fontStyle) != null ? _b : \"normal\";\n    });\n    const fontFamily = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.font) == null ? void 0 : _a.fontFamily) != null ? _b : \"sans-serif\";\n    });\n    const gapX = computed(() => props.gap[0]);\n    const gapY = computed(() => props.gap[1]);\n    const gapXCenter = computed(() => gapX.value / 2);\n    const gapYCenter = computed(() => gapY.value / 2);\n    const offsetLeft = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.offset) == null ? void 0 : _a[0]) != null ? _b : gapXCenter.value;\n    });\n    const offsetTop = computed(() => {\n      var _a, _b;\n      return (_b = (_a = props.offset) == null ? void 0 : _a[1]) != null ? _b : gapYCenter.value;\n    });\n    const getMarkStyle = () => {\n      const markStyle = {\n        zIndex: props.zIndex,\n        position: \"absolute\",\n        left: 0,\n        top: 0,\n        width: \"100%\",\n        height: \"100%\",\n        pointerEvents: \"none\",\n        backgroundRepeat: \"repeat\"\n      };\n      let positionLeft = offsetLeft.value - gapXCenter.value;\n      let positionTop = offsetTop.value - gapYCenter.value;\n      if (positionLeft > 0) {\n        markStyle.left = `${positionLeft}px`;\n        markStyle.width = `calc(100% - ${positionLeft}px)`;\n        positionLeft = 0;\n      }\n      if (positionTop > 0) {\n        markStyle.top = `${positionTop}px`;\n        markStyle.height = `calc(100% - ${positionTop}px)`;\n        positionTop = 0;\n      }\n      markStyle.backgroundPosition = `${positionLeft}px ${positionTop}px`;\n      return markStyle;\n    };\n    const containerRef = shallowRef(null);\n    const watermarkRef = shallowRef();\n    const stopObservation = ref(false);\n    const destroyWatermark = () => {\n      if (watermarkRef.value) {\n        watermarkRef.value.remove();\n        watermarkRef.value = void 0;\n      }\n    };\n    const appendWatermark = (base64Url, markWidth) => {\n      var _a;\n      if (containerRef.value && watermarkRef.value) {\n        stopObservation.value = true;\n        watermarkRef.value.setAttribute(\"style\", getStyleStr({\n          ...getMarkStyle(),\n          backgroundImage: `url('${base64Url}')`,\n          backgroundSize: `${Math.floor(markWidth)}px`\n        }));\n        (_a = containerRef.value) == null ? void 0 : _a.append(watermarkRef.value);\n        setTimeout(() => {\n          stopObservation.value = false;\n        });\n      }\n    };\n    const getMarkSize = ctx => {\n      let defaultWidth = 120;\n      let defaultHeight = 64;\n      const image = props.image;\n      const content = props.content;\n      const width = props.width;\n      const height = props.height;\n      if (!image && ctx.measureText) {\n        ctx.font = `${Number(fontSize.value)}px ${fontFamily.value}`;\n        const contents = Array.isArray(content) ? content : [content];\n        const sizes = contents.map(item => {\n          const metrics = ctx.measureText(item);\n          return [metrics.width, metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent];\n        });\n        defaultWidth = Math.ceil(Math.max(...sizes.map(size => size[0])));\n        defaultHeight = Math.ceil(Math.max(...sizes.map(size => size[1]))) * contents.length + (contents.length - 1) * FontGap;\n      }\n      return [width != null ? width : defaultWidth, height != null ? height : defaultHeight];\n    };\n    const getClips = useClips();\n    const renderWatermark = () => {\n      const canvas = document.createElement(\"canvas\");\n      const ctx = canvas.getContext(\"2d\");\n      const image = props.image;\n      const content = props.content;\n      const rotate = props.rotate;\n      if (ctx) {\n        if (!watermarkRef.value) {\n          watermarkRef.value = document.createElement(\"div\");\n        }\n        const ratio = getPixelRatio();\n        const [markWidth, markHeight] = getMarkSize(ctx);\n        const drawCanvas = drawContent => {\n          const [textClips, clipWidth] = getClips(drawContent || \"\", rotate, ratio, markWidth, markHeight, {\n            color: color.value,\n            fontSize: fontSize.value,\n            fontStyle: fontStyle.value,\n            fontWeight: fontWeight.value,\n            fontFamily: fontFamily.value\n          }, gapX.value, gapY.value);\n          appendWatermark(textClips, clipWidth);\n        };\n        if (image) {\n          const img = new Image();\n          img.onload = () => {\n            drawCanvas(img);\n          };\n          img.onerror = () => {\n            drawCanvas(content);\n          };\n          img.crossOrigin = \"anonymous\";\n          img.referrerPolicy = \"no-referrer\";\n          img.src = image;\n        } else {\n          drawCanvas(content);\n        }\n      }\n    };\n    onMounted(() => {\n      renderWatermark();\n    });\n    watch(() => props, () => {\n      renderWatermark();\n    }, {\n      deep: true,\n      flush: \"post\"\n    });\n    onBeforeUnmount(() => {\n      destroyWatermark();\n    });\n    const onMutate = mutations => {\n      if (stopObservation.value) {\n        return;\n      }\n      mutations.forEach(mutation => {\n        if (reRendering(mutation, watermarkRef.value)) {\n          destroyWatermark();\n          renderWatermark();\n        }\n      });\n    };\n    useMutationObserver(containerRef, onMutate, {\n      attributes: true\n    });\n    return (_ctx, _cache) => {\n      return openBlock(), createElementBlock(\"div\", {\n        ref_key: \"containerRef\",\n        ref: containerRef,\n        style: normalizeStyle([style])\n      }, [renderSlot(_ctx.$slots, \"default\")], 4);\n    };\n  }\n});\nvar Watermark = /* @__PURE__ */_export_sfc(_sfc_main, [[\"__file\", \"/home/runner/work/element-plus/element-plus/packages/components/watermark/src/watermark.vue\"]]);\nexport { Watermark as default };","map":{"version":3,"names":["name","style","position","color","computed","_a","_b","props","font","fontSize","fontWeight","fontStyle","fontFamily","gapX","gap","gapY","gapXCenter","value","gapYCenter","offsetLeft","offset","offsetTop","getMarkStyle","markStyle","zIndex","left","top","width","height","pointerEvents","backgroundRepeat","positionLeft","positionTop","backgroundPosition","containerRef","shallowRef","watermarkRef","stopObservation","ref","destroyWatermark","remove","appendWatermark","base64Url","markWidth","setAttribute","getStyleStr","backgroundImage","backgroundSize","Math","floor","append","setTimeout","getMarkSize","ctx","defaultWidth","defaultHeight","image","content","measureText","Number","contents","Array","isArray","sizes","map","item","metrics","fontBoundingBoxAscent","fontBoundingBoxDescent","ceil","max","size","length","FontGap","getClips","useClips","renderWatermark","canvas","document","createElement","getContext","rotate","ratio","getPixelRatio","markHeight","drawCanvas","drawContent","textClips","clipWidth","img","Image","onload","onerror","crossOrigin","referrerPolicy","src","onMounted","watch"],"sources":["../../../../../../packages/components/watermark/src/watermark.vue"],"sourcesContent":["<template>\n  <div ref=\"containerRef\" :style=\"[style]\">\n    <slot />\n  </div>\n</template>\n\n<script lang=\"ts\" setup>\nimport {\n  computed,\n  onBeforeUnmount,\n  onMounted,\n  ref,\n  shallowRef,\n  watch,\n} from 'vue'\nimport { useMutationObserver } from '@vueuse/core'\nimport { watermarkProps } from './watermark'\nimport { getPixelRatio, getStyleStr, reRendering } from './utils'\nimport useClips, { FontGap } from './useClips'\nimport type { WatermarkProps } from './watermark'\nimport type { CSSProperties } from 'vue'\n\ndefineOptions({\n  name: 'ElWatermark',\n})\n\nconst style: CSSProperties = {\n  position: 'relative',\n}\n\nconst props = defineProps(watermarkProps)\nconst color = computed(() => props.font?.color ?? 'rgba(0,0,0,.15)')\nconst fontSize = computed(() => props.font?.fontSize ?? 16)\nconst fontWeight = computed(() => props.font?.fontWeight ?? 'normal')\nconst fontStyle = computed(() => props.font?.fontStyle ?? 'normal')\nconst fontFamily = computed(() => props.font?.fontFamily ?? 'sans-serif')\n\nconst gapX = computed(() => props.gap[0])\nconst gapY = computed(() => props.gap[1])\nconst gapXCenter = computed(() => gapX.value / 2)\nconst gapYCenter = computed(() => gapY.value / 2)\nconst offsetLeft = computed(() => props.offset?.[0] ?? gapXCenter.value)\nconst offsetTop = computed(() => props.offset?.[1] ?? gapYCenter.value)\n\nconst getMarkStyle = () => {\n  const markStyle: CSSProperties = {\n    zIndex: props.zIndex,\n    position: 'absolute',\n    left: 0,\n    top: 0,\n    width: '100%',\n    height: '100%',\n    pointerEvents: 'none',\n    backgroundRepeat: 'repeat',\n  }\n\n  /** Calculate the style of the offset */\n  let positionLeft = offsetLeft.value - gapXCenter.value\n  let positionTop = offsetTop.value - gapYCenter.value\n  if (positionLeft > 0) {\n    markStyle.left = `${positionLeft}px`\n    markStyle.width = `calc(100% - ${positionLeft}px)`\n    positionLeft = 0\n  }\n  if (positionTop > 0) {\n    markStyle.top = `${positionTop}px`\n    markStyle.height = `calc(100% - ${positionTop}px)`\n    positionTop = 0\n  }\n  markStyle.backgroundPosition = `${positionLeft}px ${positionTop}px`\n\n  return markStyle\n}\n\nconst containerRef = shallowRef<HTMLDivElement | null>(null)\nconst watermarkRef = shallowRef<HTMLDivElement>()\nconst stopObservation = ref(false)\n\nconst destroyWatermark = () => {\n  if (watermarkRef.value) {\n    watermarkRef.value.remove()\n    watermarkRef.value = undefined\n  }\n}\nconst appendWatermark = (base64Url: string, markWidth: number) => {\n  if (containerRef.value && watermarkRef.value) {\n    stopObservation.value = true\n    watermarkRef.value.setAttribute(\n      'style',\n      getStyleStr({\n        ...getMarkStyle(),\n        backgroundImage: `url('${base64Url}')`,\n        backgroundSize: `${Math.floor(markWidth)}px`,\n      })\n    )\n    containerRef.value?.append(watermarkRef.value)\n    // Delayed execution\n    setTimeout(() => {\n      stopObservation.value = false\n    })\n  }\n}\n\n/**\n * Get the width and height of the watermark. The default values are as follows\n * Image: [120, 64]; Content: It's calculated by content;\n */\nconst getMarkSize = (ctx: CanvasRenderingContext2D) => {\n  let defaultWidth = 120\n  let defaultHeight = 64\n  const image = props.image\n  const content = props.content\n  const width = props.width\n  const height = props.height\n  if (!image && ctx.measureText) {\n    ctx.font = `${Number(fontSize.value)}px ${fontFamily.value}`\n    const contents = Array.isArray(content) ? content : [content]\n    const sizes = contents.map((item) => {\n      const metrics = ctx.measureText(item!)\n\n      return [\n        metrics.width,\n        metrics.fontBoundingBoxAscent + metrics.fontBoundingBoxDescent,\n      ]\n    })\n    defaultWidth = Math.ceil(Math.max(...sizes.map((size) => size[0])))\n    defaultHeight =\n      Math.ceil(Math.max(...sizes.map((size) => size[1]))) * contents.length +\n      (contents.length - 1) * FontGap\n  }\n  return [width ?? defaultWidth, height ?? defaultHeight] as const\n}\n\nconst getClips = useClips()\n\nconst renderWatermark = () => {\n  const canvas = document.createElement('canvas')\n  const ctx = canvas.getContext('2d')\n  const image = props.image\n  const content = props.content\n  const rotate = props.rotate\n\n  if (ctx) {\n    if (!watermarkRef.value) {\n      watermarkRef.value = document.createElement('div')\n    }\n\n    const ratio = getPixelRatio()\n    const [markWidth, markHeight] = getMarkSize(ctx)\n\n    const drawCanvas = (\n      drawContent?: NonNullable<WatermarkProps['content']> | HTMLImageElement\n    ) => {\n      const [textClips, clipWidth] = getClips(\n        drawContent || '',\n        rotate,\n        ratio,\n        markWidth,\n        markHeight,\n        {\n          color: color.value,\n          fontSize: fontSize.value,\n          fontStyle: fontStyle.value,\n          fontWeight: fontWeight.value,\n          fontFamily: fontFamily.value,\n        },\n        gapX.value,\n        gapY.value\n      )\n\n      appendWatermark(textClips, clipWidth)\n    }\n\n    if (image) {\n      const img = new Image()\n      img.onload = () => {\n        drawCanvas(img)\n      }\n      img.onerror = () => {\n        drawCanvas(content)\n      }\n      img.crossOrigin = 'anonymous'\n      img.referrerPolicy = 'no-referrer'\n      img.src = image\n    } else {\n      drawCanvas(content)\n    }\n  }\n}\n\nonMounted(() => {\n  renderWatermark()\n})\n\nwatch(\n  () => props,\n  () => {\n    renderWatermark()\n  },\n  {\n    deep: true,\n    flush: 'post',\n  }\n)\n\nonBeforeUnmount(() => {\n  destroyWatermark()\n})\n\nconst onMutate = (mutations: MutationRecord[]) => {\n  if (stopObservation.value) {\n    return\n  }\n  mutations.forEach((mutation) => {\n    if (reRendering(mutation, watermarkRef.value)) {\n      destroyWatermark()\n      renderWatermark()\n    }\n  })\n}\n\nuseMutationObserver(containerRef, onMutate, {\n  attributes: true,\n})\n</script>\n"],"mappings":"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"},"metadata":{},"sourceType":"module","externalDependencies":[]}